import asyncio
import os
import uuid
from textwrap import dedent
from typing import AsyncIterator, List, Optional, Dict, Any, Iterator
from pathlib import Path

from agno.agent import Agent
from agno.run.response import RunResponse
from agno.memory.v2.db.sqlite import SqliteMemoryDb
from agno.memory.v2.memory import Memory
from agno.team import Team
from agno.tools.file import FileTools
from agno.tools.shell import ShellTools
from agno.media import Image
from agno.storage.sqlite import SqliteStorage
from agno.tools.googlesearch import GoogleSearchTools

from core.model_factory import get_model_instance, DEFAULT_MODEL_ID
from agents.environment_perception_agent import (
    DEPLOYMENT_ARCHITECTURE_REPORTER_AGENT_CONFIG,
    DEPLOYMENT_ARCHITECTURE_REPORTER_AGENT_ID
)
from agents.attack_surface_identification_agent import (
    ATTACK_SURFACE_PLANNING_AGENT_CONFIG, # This is the _v2_whitebox version
    ATTACK_SURFACE_PLANNING_AGENT_ID
)
from agents.attack_surface_refiner_agent import (
    ATTACK_SURFACE_REFINER_AGENT_CONFIG,
    ATTACK_SURFACE_REFINER_AGENT_ID
)
from agents.deep_dive_security_auditor_agent import (
    DEEP_DIVE_SECURITY_AUDITOR_AGENT_CONFIG,
    DEEP_DIVE_SECURITY_AUDITOR_AGENT_ID
)
from tools.report_repository_tools import (
    save_report_to_repository,
    read_report_from_repository,
    SHARED_REPORTS_DIR
)
from tools.session_state_tools import ReadSessionStateTool, UpdateSessionStateTool
from tools.project_structure_tools import ListDirectoryTreeTool
from agno.tools import Function

from .team_hooks import log_before_team_tool_call, log_after_team_tool_call

# --- Report Filenames Constants ---
DEPLOYMENT_REPORT_FILENAME = "DeploymentArchitectureReport.md"
PLAN_FILENAME = "AttackSurfaceInvestigationPlan_whitebox.md" # Generated by Planner Agent
AGGREGATED_DEEP_DIVE_FILENAME_PREFIX = "DeepDiveAuditFindings_Aggregated" # Full report at the end
INDIVIDUAL_DEEP_DIVE_REPORT_PREFIX = "DeepDiveReport_Task" # For individual task reports from Auditor Agent

# --- Team Definition ---
SECURITY_AUDIT_TEAM_ID = "security_audit_team_v1"
SECURITY_AUDIT_TEAM_NAME = "SecurityAuditTeam"
SECURITY_AUDIT_TEAM_DESCRIPTION = dedent((
    "A coordinated team of AI agents designed to perform a multi-stage security audit. "
    "Stage 1: Environment Perception. Stage 2: Attack Surface Planning. Stage 3: Deep-Dive Auditing."
))

# --- Team Leader (Team itself) Instructions ---
# Use unique placeholders like <<VARIABLE_NAME>> to avoid conflicts with JSON-like structures.
TEAM_LEADER_INSTRUCTIONS_TEMPLATE = dedent('''\
IMPORTANT: Your primary language for all outputs, internal reasoning, and communication to the user is CHINESE (中文).

You are the Team Leader of the Security Audit Team. Your goal is to orchestrate a four-stage security audit of a software project based on an initial user query.
You will use the `<<PLAN_FILENAME>>` file as the primary source for managing audit tasks and tracking progress. Session state will be used for minimal control data.

**Project Shared Directory:**
All reports are saved and read from: <<SHARED_REPORTS_DIR>>.
Ensure all agents use this path correctly.

**Report Filenames:**
- Stage 1 (Environment Reporter) output: <<DEPLOYMENT_REPORT_FILENAME>>
- Stage 2 (Attack Planner) output: <<PLAN_FILENAME>> (This plan will contain Markdown checkboxes for tasks: `- [ ] Task Description`)
- Stage 3 (Attack Surface Refiner) output: `RefinedAttackSurface_For_<原始任务标识>.md`（每个任务一个，内容为建议/关注点列表，仅供参考）
- Stage 4 (Deep Dive Auditor) individual task reports will be named like: <<INDIVIDUAL_DEEP_DIVE_REPORT_PREFIX>>_[task_index_or_name].md
- Your final aggregated report of all deep dive findings: <<AGGREGATED_DEEP_DIVE_FILENAME_PREFIX>>_[timestamp].md

**Your Tools:**
- `atransfer_task_to_member`: To delegate tasks to member agents. Arguments: `member_id` (str), `task_description` (str), `expected_output` (str, optional).
- `FileTools` (e.g., `FileTools.read_file`, `FileTools.edit_file`). Crucially, `FileTools.edit_file` will be used to update task statuses in `<<PLAN_FILENAME>>`.
- `ReadSessionStateTool`: To read from `session_state`. Args: `key` (str).
- `UpdateSessionStateTool`: To modify `session_state`. Args: `key` (str), `value` (any), `action` (str, optional: 'set', 'append', 'increment'). Default action is 'set'.
- `save_report_to_repository`: To save report content.
- `read_report_from_repository`: To read report content.

**Session State Variables You Will Manage (accessed via ReadSessionStateTool and UpdateSessionStateTool):**
- `current_audit_task_raw_line`: A string holding the raw Markdown line of the task currently being processed (e.g., "- [ ] Task 1 description"). Initialized to an empty string or null.
- `audit_plan_filepath`: String, the full path to the `<<PLAN_FILENAME>>` file (e.g., `<<SHARED_REPORTS_DIR>>/<<PLAN_FILENAME>>`). This will be set after Phase 2.
- `individual_report_files`: A list of strings (filenames of reports from DeepDive Auditor). Initialized to an empty list.

**Workflow:**

**Phase 0: Initial Setup**
- You will receive an initial user query.
- `session_state` is pre-initialized with `current_audit_task_raw_line = ""` and `individual_report_files = []`. `audit_plan_filepath` will be set later.

**Phase 1: Environment Perception**
1.  Invoke the `deployment_architecture_reporter_v1` (this is the exact `member_id` for the DeploymentArchitectureReporterAgent) using the `atransfer_task_to_member` tool.
2.  Its task is to analyze the project and produce a report. Instruct it that its final output artifact should be the content of the report, which it will save using the `save_report_to_repository` tool with the `report_name` `<<DEPLOYMENT_REPORT_FILENAME>>`.
    Provide `expected_output="A confirmation message stating the report named '<<DEPLOYMENT_REPORT_FILENAME>>' has been successfully saved."` to the `atransfer_task_to_member` call.
3.  The `save_report_to_repository` tool will automatically place this file at `<<SHARED_REPORTS_DIR>>/<<DEPLOYMENT_REPORT_FILENAME>>`. You will verify its existence there.
4.  Confirm the report is saved at the correct location. If not, report error and stop.

**Phase 2: Attack Surface Planning & Plan Availability**
1.  Invoke the `<<ATTACK_SURFACE_PLANNING_AGENT_ID>>` using `atransfer_task_to_member`.
2.  Its task is to read `<<SHARED_REPORTS_DIR>>/<<DEPLOYMENT_REPORT_FILENAME>>`, consider the user query, and create an attack surface investigation plan. Instruct it explicitly that its final output artifact should be the content of this plan, which it **MUST** save using the `save_report_to_repository` tool with the exact `report_name` `<<PLAN_FILENAME>>`.
    Provide `expected_output="A confirmation message stating the plan named '<<PLAN_FILENAME>>' has been successfully saved."` to the `atransfer_task_to_member` call.
3.  The `save_report_to_repository` tool will automatically place this file at `<<SHARED_REPORTS_DIR>>/<<PLAN_FILENAME>>`.
4.  **Verify Plan File Existence**: After the `<<ATTACK_SURFACE_PLANNING_AGENT_ID>>` agent is expected to have saved the plan, you **MUST** use `FileTools.read_file` to attempt to read the file at `<<SHARED_REPORTS_DIR>>/<<PLAN_FILENAME>>`. This is to confirm its existence and readability. If this `FileTools.read_file` call fails (e.g., file not found), you must report a critical error stating the plan file is missing and then **STOP** all further operations. Do not proceed to Phase 3 if the plan file cannot be verified.

**Phase 3: Attack Surface Refinement (Per-Task, Suggestions Only)**
1.  For each uncompleted task in the plan file (`- [ ] ...`):
    a.  Extract the full task context (multi-line Markdown block) as described previously.
    b.  Delegate this task context to the `<<ATTACK_SURFACE_REFINER_AGENT_ID>>` using `atransfer_task_to_member`.
        Provide `expected_output="A string containing ONLY the filename of the saved refined attack surface report."` to this `atransfer_task_to_member` call.
    c.  The refiner agent will output a filename (e.g., `RefinedAttackSurface_For_<原始任务标识>.md`) containing its suggestions/attack surface findings for this task. This output **must only be treated as suggestions and reference for the next phase, not as hard constraints**.
    d.  Read the content of this file using `read_report_from_repository`.
    e.  Pass the content of this refined report（即建议/关注点列表）作为 `task_description` 传递给 DeepDive Auditor。

**Phase 4: Iterative Deep-Dive Auditing (Managed via Markdown Plan File)**
1.  For each task, after receiving the refined suggestions from Phase 3:
    a.  Delegate the refined task (suggestions) to the `<<DEEP_DIVE_SECURITY_AUDITOR_AGENT_ID>>` using `atransfer_task_to_member`.
        Provide `expected_output="A string containing ONLY the filename of the saved deep dive audit report for this task."` to this `atransfer_task_to_member` call.
    b.  The DeepDive Auditor is expected to perform its audit and its final output will be a string, which is the `new_report_filename` of the report it saved.
    c.  Upon receiving this `new_report_filename` string from the `<<DEEP_DIVE_SECURITY_AUDITOR_AGENT_ID>>`, consider its assigned task successfully completed. You will then proceed to record this filename and mark the task as complete in the plan.
    d.  Use `UpdateSessionStateTool` with parameters: `key='individual_report_files'`, `value=the_received_new_report_filename`, `action='append'`.
    e.  Mark the task as complete in the plan file using `FileTools.edit_file` as before.
    f.  Clear current task from session state (optional).
    g.  Loop to next uncompleted task.

**Final Aggregation and Output**
1.  After all tasks are complete, aggregate all individual deep dive reports as before.
2.  Save the final report and output the filename to the user.

Be methodical. If tool calls fail or agents fail, report clearly. Explicitly state the tool calls you are making with their parameters.
Ensure that when using `FileTools.edit_file` to mark tasks as complete, the exact line is targeted for replacement to avoid corrupting the plan file.
''')


class SecurityAuditTeam(Team):
    def __init__(
        self,
        user_id: Optional[str] = "default_user",
        team_id: str = "security_audit_team_v1",
        model_id: str = DEFAULT_MODEL_ID,
        team_leader_model_id: str = DEFAULT_MODEL_ID,
        env_reporter_model_id: str = DEFAULT_MODEL_ID,
        attack_planning_model_id: str = DEFAULT_MODEL_ID,
        attack_surface_refiner_model_id: str = DEFAULT_MODEL_ID,
        deep_dive_auditor_model_id: str = DEFAULT_MODEL_ID,
        name: str = "SecurityAuditTeam",
        initial_audit_plan_items: Optional[List[Dict[str, Any]]] = None,
        initial_current_audit_item_index: int = 0,
        initial_individual_report_files: Optional[List[str]] = None,
        db_path: str = "security_audit_team_memory.db",
        **kwargs: Any,
    ):
        self.model_id = model_id
        self.team_leader_model_id = team_leader_model_id
        self.env_reporter_model_id = env_reporter_model_id
        self.attack_planning_model_id = attack_planning_model_id
        self.deep_dive_auditor_model_id = deep_dive_auditor_model_id
        self.attack_surface_refiner_model_id = attack_surface_refiner_model_id
        self.db_path = db_path
        self.user_id = user_id if user_id else f"team_user_{uuid.uuid4()}"
        
        # Get model instances
        team_leader_model = get_model_instance(self.team_leader_model_id)
        env_reporter_model = get_model_instance(self.env_reporter_model_id)
        attack_planning_model = get_model_instance(self.attack_planning_model_id)
        deep_dive_auditor_model = get_model_instance(self.deep_dive_auditor_model_id)
        attack_surface_refiner_model = get_model_instance(self.attack_surface_refiner_model_id)
        
        sqlite_db_backend = SqliteMemoryDb(db_file=self.db_path, table_name="team_memory_table")
        team_main_memory = Memory(db=sqlite_db_backend)

        team_chat_storage = SqliteStorage(
            table_name="team_chat_history", 
            db_file=self.db_path,
            auto_upgrade_schema=True
        )

        # Common file tools base directory
        common_base_dir = Path("/data/target_code")

        reporter_file_tools = FileTools(base_dir=common_base_dir)
        reporter_shell_tools = ShellTools()
        
        auditor_file_tools = FileTools(base_dir=common_base_dir) # For DeepDive Auditor
        auditor_shell_tools = ShellTools() # For DeepDive Auditor
        google_search_tool = GoogleSearchTools() # Instantiate GoogleSearchTools for Auditor
        list_directory_tree_tool = ListDirectoryTreeTool(base_dir=str(common_base_dir)) # Instantiate new tool


        # session_state_toolkit = SessionStateManagementTools()
        team_tools = [
            reporter_file_tools,
            reporter_shell_tools,
            auditor_file_tools,
            auditor_shell_tools,
            # session_state_toolkit,
            # save_report_to_repository, # <--- Removed as per user request
            read_report_from_repository
        ]
        
        # Instantiate and wrap session state tools for the Team Leader
        update_tool_instance = UpdateSessionStateTool()
        read_tool_instance = ReadSessionStateTool()

        update_session_state_tool_func = Function.from_callable(update_tool_instance.__call__)
        update_session_state_tool_func.name = update_tool_instance.name
        update_session_state_tool_func.description = update_tool_instance.description

        read_session_state_tool_func = Function.from_callable(read_tool_instance.__call__)
        read_session_state_tool_func.name = read_tool_instance.name
        read_session_state_tool_func.description = read_tool_instance.description

        list_directory_tree_tool_func = Function.from_callable(list_directory_tree_tool.__call__)
        list_directory_tree_tool_func.name = list_directory_tree_tool.name
        list_directory_tree_tool_func.description = list_directory_tree_tool.description
        
        team_tools.extend([
            update_session_state_tool_func,
            read_session_state_tool_func,
        ])
        
        current_session_state = {
            'audit_plan_items': initial_audit_plan_items or [],
            'current_audit_item_index': initial_current_audit_item_index or 0,
            'individual_report_files': initial_individual_report_files or []
        }

        env_perception_agent = Agent(
            agent_id=DEPLOYMENT_ARCHITECTURE_REPORTER_AGENT_ID,
            name=DEPLOYMENT_ARCHITECTURE_REPORTER_AGENT_CONFIG.name,
            description=DEPLOYMENT_ARCHITECTURE_REPORTER_AGENT_CONFIG.description,
            instructions=DEPLOYMENT_ARCHITECTURE_REPORTER_AGENT_CONFIG.instructions,
            tools=[reporter_file_tools, reporter_shell_tools, save_report_to_repository],
            model=env_reporter_model,
            monitoring=True,
            memory=team_main_memory,
            enable_user_memories=False,
        )

        attack_planning_agent = Agent(
            agent_id=ATTACK_SURFACE_PLANNING_AGENT_ID,
            name=ATTACK_SURFACE_PLANNING_AGENT_CONFIG.name,
            description=ATTACK_SURFACE_PLANNING_AGENT_CONFIG.description,
            instructions=ATTACK_SURFACE_PLANNING_AGENT_CONFIG.instructions,
            tools=ATTACK_SURFACE_PLANNING_AGENT_CONFIG.tools + [read_report_from_repository, save_report_to_repository],
            model=attack_planning_model,
            monitoring=True,
            memory=team_main_memory,
            enable_user_memories=False,
            reasoning=True,
        )

        attack_surface_refiner_agent = Agent(
            agent_id=ATTACK_SURFACE_REFINER_AGENT_ID,
            name=ATTACK_SURFACE_REFINER_AGENT_CONFIG.name,
            description=ATTACK_SURFACE_REFINER_AGENT_CONFIG.description,
            instructions=ATTACK_SURFACE_REFINER_AGENT_CONFIG.instructions_template,
            tools=[FileTools(base_dir=common_base_dir), list_directory_tree_tool_func, save_report_to_repository, read_report_from_repository],
            model=attack_surface_refiner_model,
            monitoring=True,
            memory=team_main_memory,
            enable_user_memories=False,
            reasoning=True,
        )

        deep_dive_auditor = Agent(
            agent_id=DEEP_DIVE_SECURITY_AUDITOR_AGENT_ID,
            name=DEEP_DIVE_SECURITY_AUDITOR_AGENT_CONFIG.name,
            description=DEEP_DIVE_SECURITY_AUDITOR_AGENT_CONFIG.description,
            instructions=DEEP_DIVE_SECURITY_AUDITOR_AGENT_CONFIG.instructions_template,
            tools=[
                auditor_file_tools, 
                auditor_shell_tools, 
                read_report_from_repository, 
                save_report_to_repository,
                google_search_tool,
                list_directory_tree_tool_func
            ],
            model=deep_dive_auditor_model,
            monitoring=True,
            memory=team_main_memory,
            enable_user_memories=False,
            reasoning=False,
        )
        success_criteria = dedent(f'''\
            All tasks in the audit plan are completed.
            All vulnerabilities are identified and reported.
            A detailed report is generated.
        ''')

        # Prepare instructions by replacing placeholders
        current_instructions = TEAM_LEADER_INSTRUCTIONS_TEMPLATE
        current_instructions = current_instructions.replace("<<SHARED_REPORTS_DIR>>", SHARED_REPORTS_DIR)
        current_instructions = current_instructions.replace("<<DEPLOYMENT_REPORT_FILENAME>>", DEPLOYMENT_REPORT_FILENAME)
        current_instructions = current_instructions.replace("<<PLAN_FILENAME>>", PLAN_FILENAME)
        current_instructions = current_instructions.replace("<<INDIVIDUAL_DEEP_DIVE_REPORT_PREFIX>>", INDIVIDUAL_DEEP_DIVE_REPORT_PREFIX)
        current_instructions = current_instructions.replace("<<AGGREGATED_DEEP_DIVE_FILENAME_PREFIX>>", AGGREGATED_DEEP_DIVE_FILENAME_PREFIX)
        # Placeholders for agent IDs also need to be replaced if they are part of the template string
        current_instructions = current_instructions.replace("<<ATTACK_SURFACE_PLANNING_AGENT_ID>>", ATTACK_SURFACE_PLANNING_AGENT_ID)
        current_instructions = current_instructions.replace("<<DEEP_DIVE_SECURITY_AUDITOR_AGENT_ID>>", DEEP_DIVE_SECURITY_AUDITOR_AGENT_ID)


        super().__init__(
            team_id=team_id,
            name=name,
            description=SECURITY_AUDIT_TEAM_DESCRIPTION,
            model=team_leader_model,
            instructions=current_instructions, # Use the processed instructions
            members=[
                env_perception_agent,
                attack_planning_agent,
                attack_surface_refiner_agent,
                deep_dive_auditor
            ],
            tools=team_tools,
            user_id=self.user_id,
            memory=team_main_memory,
            storage=team_chat_storage,
            session_state=current_session_state,
            debug_mode=True,
            enable_team_history=True,
            add_member_tools_to_system_message=False,
            num_of_interactions_from_history=3,
            read_team_history=False,
            enable_agentic_context=True,
            **kwargs,
        )
        self.db_path = db_path 
        print(f"SecurityAuditTeam '{name}' initialized with leader model '{model_id}'.")

    async def stream_team_audit(
        self,
        initial_user_query: str,
        run_id: Optional[str] = None,
        session_id: Optional[str] = None,
        images: Optional[List[Image]] = None,
    ) -> AsyncIterator[RunResponse]:
        if not run_id:
            run_id = f"run_{uuid.uuid4()}"
        if not session_id:
            session_id = f"session_{uuid.uuid4()}"

        print(f"Starting Team Audit with Run ID: {run_id}, Session ID: {session_id}, User ID: {self.user_id}")
        print(f"Initial User Query: {initial_user_query}")
        print(f"Reports will be saved in: {SHARED_REPORTS_DIR}")
        os.makedirs(SHARED_REPORTS_DIR, exist_ok=True)

        async for response_chunk in await self.arun(
            message=initial_user_query,
            run_id=run_id,
            session_id=session_id,
            images=images,
            stream=True,
        ):
            yield response_chunk
        print(f"Team Audit Run ID {run_id} completed.")

async def main():
    print(f"Shared reports will be in: {os.path.abspath(SHARED_REPORTS_DIR)}")

    audit_team = SecurityAuditTeam(model_id="openrouter/google/gemini-2.5-flash-preview-05-20", user_id="test_cli_user_main_async")
    
    test_query = "Perform a security audit of the provided project. The project is a simple Python application with a pom.xml file. Identify potential vulnerabilities."

    print("\n--- Streaming Team Audit (Asynchronous) ---")
    async for chunk in audit_team.stream_team_audit(initial_user_query=test_query):
        if chunk.event == "on_agent_action_end" and chunk.run_id == audit_team.team.id : 
             if chunk.data and chunk.data.get("output"):
                print(f"\n[Team Log Stream] Event: {chunk.event}, Agent: {chunk.run_id}")
                print(f"Content: {chunk.data.get('output')[:500]}...") 
        elif chunk.event == "on_tool_use":
            print(f"\n[Team Log Stream] Event: {chunk.event}, Agent: {chunk.run_id}, Tool: {chunk.data.get('name')}")
            if chunk.data.get("input"): print(f"Tool Input: {chunk.data.get('input')}")
        elif chunk.event == "on_tool_end":
             print(f"\n[Team Log Stream] Event: {chunk.event}, Agent: {chunk.run_id}, Tool: {chunk.data.get('name')}")
             if chunk.data.get("output"): print(f"Tool Output: {chunk.data.get('output')[:300]}...")
        elif chunk.event == "on_agent_stream_chunk":
            if chunk.run_id == audit_team.team.id: 
                 print(chunk.data.get("output_chunk", ""), end="", flush=True)

    print("\n--- Team Audit Complete (Asynchronous) ---")
    print(f"Final reports should be in: {SHARED_REPORTS_DIR}")
    print("Check for files like:")
    print(f"- {DEPLOYMENT_REPORT_FILENAME}")
    print(f"- {PLAN_FILENAME}")
    print(f"- Files starting with {INDIVIDUAL_DEEP_DIVE_REPORT_PREFIX}")
    print(f"- Files starting with {AGGREGATED_DEEP_DIVE_FILENAME_PREFIX}")

if __name__ == "__main__":
    import sys
    sys.path.append(os.path.join(os.path.dirname(__file__), '../..'))
    
    asyncio.run(main()) 