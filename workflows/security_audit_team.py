import asyncio
import os
import uuid
from textwrap import dedent
from typing import AsyncIterator, List, Optional, Dict, Any

from agno.agent import Agent
from agno.run.response import RunResponse
from agno.memory.v2.db.sqlite import SqliteMemoryDb
from agno.memory.v2.memory import Memory
from agno.team import Team
from agno.tools.file import FileTools
from agno.tools.shell import ShellTools
from agno.media import Image

from core.model_factory import get_model_instance, DEFAULT_MODEL_ID
from agents.environment_perception_agent import (
    DEPLOYMENT_ARCHITECTURE_REPORTER_AGENT_CONFIG,
    DEPLOYMENT_ARCHITECTURE_REPORTER_AGENT_ID
)
from agents.attack_surface_identification_agent import (
    ATTACK_SURFACE_PLANNING_AGENT_CONFIG, # This is the _v2_whitebox version
    ATTACK_SURFACE_PLANNING_AGENT_ID
)
from agents.deep_dive_security_auditor_agent import (
    DEEP_DIVE_SECURITY_AUDITOR_AGENT_CONFIG,
    DEEP_DIVE_SECURITY_AUDITOR_AGENT_ID
)
from tools.report_repository_tools import (
    save_report_to_repository,
    read_report_from_repository,
    SHARED_REPORTS_DIR
)
from tools.session_state_tools import UpdateSessionStateTool, ReadSessionStateTool

# --- Report Filenames Constants ---
DEPLOYMENT_REPORT_FILENAME = "DeploymentArchitectureReport.md"
PLAN_FILENAME = "AttackSurfaceInvestigationPlan_whitebox.md" # Generated by Planner Agent
AGGREGATED_DEEP_DIVE_FILENAME_PREFIX = "DeepDiveAuditFindings_Aggregated" # Full report at the end
INDIVIDUAL_DEEP_DIVE_REPORT_PREFIX = "DeepDiveReport_Task" # For individual task reports from Auditor Agent

# --- Team Definition ---
SECURITY_AUDIT_TEAM_ID = "security_audit_team_v1"
SECURITY_AUDIT_TEAM_NAME = "SecurityAuditTeam"
SECURITY_AUDIT_TEAM_DESCRIPTION = dedent((
    "A coordinated team of AI agents designed to perform a multi-stage security audit. "
    "Stage 1: Environment Perception. Stage 2: Attack Surface Planning. Stage 3: Deep-Dive Auditing."
))

# --- Team Leader (Team itself) Instructions ---
# This will be the most complex part and will be refined.
TEAM_LEADER_INSTRUCTIONS = dedent(f'''\
You are the Team Leader of the Security Audit Team. Your goal is to orchestrate a three-stage security audit of a software project based on an initial user query. You will use `session_state` to manage the list of audit tasks and track progress, interacting with it VIA DEDICATED TOOLS.

**Project Shared Directory:**
All reports are saved and read from: `{SHARED_REPORTS_DIR}`.
Ensure all agents use this path correctly.

**Report Filenames:**
- Stage 1 (Environment Reporter) output: `{DEPLOYMENT_REPORT_FILENAME}`
- Stage 2 (Attack Planner) output: `{PLAN_FILENAME}` (This plan will contain Markdown checkboxes for tasks: `- [ ] Task Description`)
- Stage 3 (Deep Dive Auditor) individual task reports will be named like: `{INDIVIDUAL_DEEP_DIVE_REPORT_PREFIX}_[task_index_or_name].md`
- Your final aggregated report of all deep dive findings: `{AGGREGATED_DEEP_DIVE_FILENAME_PREFIX}_[timestamp].md`

**Your Tools:**
- `FileTools`: To read the `{PLAN_FILENAME}`, modify it by checking off completed tasks, and save the final aggregated report.
- `UpdateSessionStateTool`: To modify values in the team\'s session_state. Args: `key` (str), `value` (any), `action` (str, optional, e.g., "set", "append", "increment"). Default action is "set".
- `ReadSessionStateTool`: To read values from the team\'s session_state. Args: `key` (str).

**Session State Variables You Will Manage (accessed via tools):**
- `audit_plan_items`: A list of dictionaries. Example: `[{{\"raw_task_line\": \"- [ ] Task 1 description\", \"description\": \"Task 1 description\", \"status\": \"pending\"}} , ...]`
- `current_audit_item_index`: An integer. Initialized to 0.
- `aggregated_findings`: A string. Initialized to an empty string.

**Workflow:**

**Phase 0: Initial Setup**
- You will receive an initial user query.
- `session_state` is pre-initialized with `audit_plan_items = []`, `current_audit_item_index = 0`, `aggregated_findings = ""`. You can verify this using `ReadSessionStateTool` if needed.

**Phase 1: Environment Perception**
1.  Invoke the `{DEPLOYMENT_ARCHITECTURE_REPORTER_AGENT_ID}`.
2.  Its task is to analyze the project and produce `{DEPLOYMENT_REPORT_FILENAME}`.
3.  Ensure it saves this report to `{SHARED_REPORTS_DIR}/{DEPLOYMENT_REPORT_FILENAME}`.
4.  Confirm the report is saved. If not, report error and stop.

**Phase 2: Attack Surface Planning & Plan Ingestion**
1.  Invoke the `{ATTACK_SURFACE_PLANNING_AGENT_ID}`.
2.  Its task is to read `{DEPLOYMENT_REPORT_FILENAME}`, consider the user query, and create `{PLAN_FILENAME}` with Markdown checkbox tasks.
3.  Ensure it saves this plan to `{SHARED_REPORTS_DIR}/{PLAN_FILENAME}`.
4.  Confirm the plan is saved. If not, report error and stop.
5.  **Plan Ingestion into Session State:**
    a. Use `FileTools.read_file` to get the content of `{SHARED_REPORTS_DIR}/{PLAN_FILENAME}`.
    b. Parse the content line by line. For each line starting with `- [ ]`:
        i.  Extract the full task description.
        ii. Create a dictionary: `{{\"raw_task_line\": \"ORIGINAL_LINE_TEXT\", \"description\": \"EXTRACTED_DESCRIPTION\", \"status\": \"pending\"}}}}`.
        iii. **CRITICAL:** Explicitly call `UpdateSessionStateTool` with `key='audit_plan_items'`, `value=THE_DICTIONARY_ABOVE`, `action='append'`. You MUST state the tool call and its parameters clearly.
    c. After parsing ALL tasks and appending them, **CRITICAL:** Explicitly call `UpdateSessionStateTool` with `key='current_audit_item_index'`, `value=0`, `action='set'`. You MUST state this tool call and its parameters clearly.
    d. After these updates, verify `audit_plan_items` is populated and `current_audit_item_index` is 0 using `ReadSessionStateTool`. If `audit_plan_items` is empty or `current_audit_item_index` is not 0, report error and stop.

**Phase 3: Iterative Deep-Dive Auditing & Reporting (Using Session State Tools)**
1.  **Loop Start:**
    a. Use `ReadSessionStateTool(key='current_audit_item_index')` to get the `current_task_index`.
    b. Use `ReadSessionStateTool(key='audit_plan_items')` to get the `tasks_list`.
    c. **Check for Completion:** If `current_task_index` is greater than or equal to `len(tasks_list)`: Proceed to Phase 4. (If `tasks_list` was empty from Phase 2, this condition will also pass, but you should have errored out in Phase 2c).
    d. **Process Current Task:**
        i.  Get `current_task_data = tasks_list[current_task_index]`.
        ii. Extract `task_description = current_task_data['description']` and `raw_task_line = current_task_data['raw_task_line']`.
        iii. Invoke `{DEEP_DIVE_SECURITY_AUDITOR_AGENT_ID}` with `task_description` and the original user query.
        iv. Collect the agent's Markdown report.
        v.  Use `ReadSessionStateTool(key='aggregated_findings')` to get current findings, append the new report (with separator), then use `UpdateSessionStateTool` with `key='aggregated_findings'`, `value=NEW_AGGREGATED_STRING`, `action='set'`.
        vi. **Mark Task Complete in Plan File:** Use `FileTools.edit_file` to change `raw_task_line` to its completed form in `{SHARED_REPORTS_DIR}/{PLAN_FILENAME}`.
        vii. **Update Session State for Task Status (CRITICAL - Use Read-Modify-Write):**
            1. Read the entire `audit_plan_items` list using `ReadSessionStateTool(key='audit_plan_items')`.
            2. In your internal reasoning (do not show this as a separate step to the user), modify the item at `current_task_index` in the retrieved list to set its `status` to `"completed"`.
            3. Use `UpdateSessionStateTool` with `key='audit_plan_items'`, `value=THE_ENTIRE_MODIFIED_LIST`, `action='set'` to save the updated list back to session state.
        viii. **Increment Task Index in Session State:** Use `UpdateSessionStateTool` with `key='current_audit_item_index'`, `value=1`, `action='increment'`.
        ix. Go back to **Loop Start** (Phase 3, Step 1a).

**Phase 4: Final Aggregation and Output**
1.  Use `ReadSessionStateTool(key='aggregated_findings')` to get `final_report_content`.
2.  Generate a timestamp string (e.g., YYYYMMDDHHMMSS). If you cannot, use a fixed name like `AggregatedReport_Latest.md`.
3.  Construct final report filename: `{SHARED_REPORTS_DIR}/{AGGREGATED_DEEP_DIVE_FILENAME_PREFIX}_[timestamp_or_fixed_name].md`.
4.  Use `FileTools.edit_file` to save `final_report_content`.
5.  Output a completion message pointing to reports.

Be methodical. If tool calls fail or agents fail, report clearly. Explicitly state the tool calls you are making with their parameters.
If `UpdateSessionStateTool` for path `audit_plan_items.[current_task_index].status` is problematic, an alternative for step vii is: 1. Read `audit_plan_items`. 2. Modify the specific item in the retrieved list. 3. Use `UpdateSessionStateTool` to set the entire `audit_plan_items` key to this modified list.
''')


class SecurityAuditTeam:
    def __init__(self, model_id: str = DEFAULT_MODEL_ID, team_leader_model_id: Optional[str] = None, db_path: str = "team_memory.sqlite"):
        self.model_id = model_id
        self.team_leader_model_id = team_leader_model_id if team_leader_model_id else model_id # Use specific or fallback to general
        self.db_path = db_path
        self._setup_team()

    def _setup_team(self):
        # Get model instances
        team_leader_model = get_model_instance(self.team_leader_model_id) # Use the new dedicated model_id
        env_reporter_model = get_model_instance(self.model_id)
        planner_model = get_model_instance(self.model_id)
        auditor_model = get_model_instance(self.model_id)

        # 1. Environment Reporter Agent
        env_perception_agent = Agent(
            name=DEPLOYMENT_ARCHITECTURE_REPORTER_AGENT_CONFIG.name,
            description=DEPLOYMENT_ARCHITECTURE_REPORTER_AGENT_CONFIG.description,
            instructions=DEPLOYMENT_ARCHITECTURE_REPORTER_AGENT_CONFIG.instructions,
            tools=DEPLOYMENT_ARCHITECTURE_REPORTER_AGENT_CONFIG.tools + [save_report_to_repository],
            model=env_reporter_model,
        )

        # 2. Attack Surface Planning Agent
        attack_planning_agent = Agent(
            name=ATTACK_SURFACE_PLANNING_AGENT_CONFIG.name,
            description=ATTACK_SURFACE_PLANNING_AGENT_CONFIG.description,
            instructions=ATTACK_SURFACE_PLANNING_AGENT_CONFIG.instructions,
            tools=ATTACK_SURFACE_PLANNING_AGENT_CONFIG.tools + [read_report_from_repository, save_report_to_repository],
            model=planner_model,
        )

        # 3. Deep Dive Security Auditor Agent
        auditor_file_tools = FileTools()
        auditor_shell_tools = ShellTools()
        deep_dive_auditor = Agent(
            name=DEEP_DIVE_SECURITY_AUDITOR_AGENT_CONFIG.name,
            description=DEEP_DIVE_SECURITY_AUDITOR_AGENT_CONFIG.description,
            instructions=DEEP_DIVE_SECURITY_AUDITOR_AGENT_CONFIG.instructions_template,
            tools=[auditor_file_tools, auditor_shell_tools, read_report_from_repository],
            model=auditor_model,
        )
        # Ensure FileTools and ShellTools are available to the agent.
        # The AgentConfig already lists FileTools and ShellTools as classes.
        # Agno should instantiate them. If not, we might need to pass instances.

        # Team Leader (the Team itself) tools
        team_leader_file_tools = FileTools() # Instantiate FileTools
        update_state_tool = UpdateSessionStateTool() # Instantiate new tool
        read_state_tool = ReadSessionStateTool()     # Instantiate new tool
        
        # Memory
        if os.path.exists(self.db_path):
            os.remove(self.db_path) # Clean slate for demo purposes
        
        # Create the SQLite database backend
        sqlite_db_backend = SqliteMemoryDb(db_file=self.db_path, table_name="team_memory_table")
        # Create the main Memory object, wrapping the SQLite backend
        team_main_memory = Memory(db=sqlite_db_backend)


        self.team = Team(
            team_id=SECURITY_AUDIT_TEAM_ID,
            name=SECURITY_AUDIT_TEAM_NAME,
            description=SECURITY_AUDIT_TEAM_DESCRIPTION,
            model=team_leader_model,
            instructions=TEAM_LEADER_INSTRUCTIONS,
            members=[env_perception_agent, attack_planning_agent, deep_dive_auditor],
            tools=[team_leader_file_tools, update_state_tool, read_state_tool], # Add new tools to leader
            mode="coordinate",
            memory=team_main_memory, # Pass the wrapped Memory object
            session_state={'audit_plan_items': [], 'current_audit_item_index': 0, 'aggregated_findings': ""}, # Initialize session_state
            enable_team_history=True,
            share_member_interactions=False,
            enable_agentic_context=True,
            markdown=True,  # Assuming markdown is desired for outputs
            debug_mode=True,
            show_tool_calls=True,
            show_members_responses=True,
            # enable_user_memories=True, # Might be redundant if team_history & member_context are on
        )

    async def stream_team_audit(
        self,
        initial_user_query: str,
        run_id: Optional[str] = None,
        session_id: Optional[str] = None,
        images: Optional[List[Image]] = None,
    ) -> AsyncIterator[RunResponse]:
        if not run_id:
            run_id = f"run_{uuid.uuid4()}"
        if not session_id:
            session_id = f"session_{uuid.uuid4()}"

        print(f"Starting Team Audit with Run ID: {run_id}, Session ID: {session_id}")
        print(f"Initial User Query: {initial_user_query}")
        print(f"Reports will be saved in: {SHARED_REPORTS_DIR}")
        os.makedirs(SHARED_REPORTS_DIR, exist_ok=True)

        # Clear previous reports for a clean run (optional, for demo)
        # for f_name in [DEPLOYMENT_REPORT_FILENAME, PLAN_FILENAME]:
        #     f_path = os.path.join(SHARED_REPORTS_DIR, f_name)
        #     if os.path.exists(f_path):
        #         os.remove(f_path)
        # for f_name in os.listdir(SHARED_REPORTS_DIR):
        #     if f_name.startswith(AGGREGATED_DEEP_DIVE_FILENAME_PREFIX) or f_name.startswith(INDIVIDUAL_DEEP_DIVE_REPORT_PREFIX):
        #         os.remove(os.path.join(SHARED_REPORTS_DIR, f_name))


        async for response_chunk in await self.team.arun(
            message=initial_user_query,
            run_id=run_id,
            session_id=session_id,
            images=images,
            stream=True,
            # stream_tool_calls=True # To see tool calls from the leader/members
        ):
            yield response_chunk
        print(f"Team Audit Run ID {run_id} completed.")

async def main():
    # Example of how to run the team
    # Ensure OPENROUTER_API_KEY is set in your environment
    # And vulnagent8.core.model_factory is configured for OpenRouter or your desired model provider

    # Create a dummy project structure and files for testing if needed
    # For example:
    # os.makedirs("../data/mall_code_test/src", exist_ok=True)
    # with open("../data/mall_code_test/src/main.py", "w") as f:
    #     f.write("print('Hello from main.py')")
    # with open("../data/mall_code_test/pom.xml", "w") as f:
    #     f.write("<project><version>1.0.0</version></project>")

    print(f"Shared reports will be in: {os.path.abspath(SHARED_REPORTS_DIR)}")

    audit_team = SecurityAuditTeam(model_id="openrouter/google/gemini-2.5-flash-preview-05-20") # or your preferred model
    
    test_query = "Perform a security audit of the provided project. The project is a simple Python application with a pom.xml file. Identify potential vulnerabilities."
    # More specific query for a real project:
    # test_query = "Audit the 'mall' project located in /data/code. Focus on its Java Spring Boot microservices (mall-admin, mall-portal, mall-search) and their interactions, paying attention to authentication, authorization, input validation, and data handling for common web vulnerabilities. The project uses Nginx as a reverse proxy and various backing services like MySQL, MongoDB, Redis, Elasticsearch, and RabbitMQ, as detailed in its docker-compose files."


    print("\n--- Streaming Team Audit ---")
    async for chunk in audit_team.stream_team_audit(initial_user_query=test_query):
        if chunk.event == "on_agent_action_end" and chunk.run_id == audit_team.team.id : # or chunk.run_id.startswith("agt_")
             if chunk.data and chunk.data.get("output"):
                print(f"\n[Team Log Stream] Event: {chunk.event}, Agent: {chunk.run_id}")
                print(f"Content: {chunk.data.get('output')[:500]}...") # Print first 500 chars
        elif chunk.event == "on_tool_use":
            print(f"\n[Team Log Stream] Event: {chunk.event}, Agent: {chunk.run_id}, Tool: {chunk.data.get('name')}")
            if chunk.data.get("input"): print(f"Tool Input: {chunk.data.get('input')}")
        elif chunk.event == "on_tool_end":
             print(f"\n[Team Log Stream] Event: {chunk.event}, Agent: {chunk.run_id}, Tool: {chunk.data.get('name')}")
             if chunk.data.get("output"): print(f"Tool Output: {chunk.data.get('output')[:300]}...")
        elif chunk.event == "on_agent_stream_chunk":
            if chunk.run_id == audit_team.team.id: # only print stream from Team Leader
                 print(chunk.data.get("output_chunk", ""), end="", flush=True)

    print("\n--- Team Audit Complete ---")
    print(f"Final reports should be in: {SHARED_REPORTS_DIR}")
    print("Check for files like:")
    print(f"- {DEPLOYMENT_REPORT_FILENAME}")
    print(f"- {PLAN_FILENAME}")
    print(f"- Files starting with {INDIVIDUAL_DEEP_DIVE_REPORT_PREFIX}")
    print(f"- Files starting with {AGGREGATED_DEEP_DIVE_FILENAME_PREFIX}")


if __name__ == "__main__":
    # To run this:
    # Ensure OPENROUTER_API_KEY is set if using OpenRouter models.
    # From the root of the 'agno' project (or wherever vulnagent8 is a module):
    # python -m vulnagent8.workflows.security_audit_team
    # asyncio.run(main())

    # For testing with a real project, you might need to adjust paths or mount volumes if running in Docker.
    # The `SHARED_REPORTS_DIR` is currently set relative to `report_repository_tools.py`.
    # We might want to make it absolute or configurable for easier Docker volume mapping.
    # For now, it resolves to `vulnagent8/tools/../../shared_reports` -> `vulnagent8/shared_reports`
    
    # HACK: For running this file directly for dev, adjust Python path
    import sys
    sys.path.append(os.path.join(os.path.dirname(__file__), '../..')) #  Adds 'agno' (parent of 'vulnagent8') to path
    
    asyncio.run(main()) 