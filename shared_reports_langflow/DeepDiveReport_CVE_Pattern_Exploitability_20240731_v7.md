# 深度审计报告：Langflow v1.4.2 - CVE 模式识别与零权限间接可利用性分析 (v7)

**审计日期:** 2024-07-31
**审计员:** DeepDiveSecurityAuditorAgent
**审计前提:** `AUTO_LOGIN = false`, 攻击者初始零权限。
**核心目标:**
1.  识别 Langflow v1.4.2 中除 `/api/v1/validate/code` 外，其他采用类似 CVE-2023-43789（输入 -> AST/动态代码 -> 执行）高风险模式的 API 端点或内部组件。
2.  分析这些“高风险模式”在零权限下，是否存在【间接】可利用性。

**参考报告:**
*   `DeploymentArchitectureReport.md`
*   `RefinedAttackSurface_For_API-REVIEW-ITEM-001.md`
*   `DeepDiveReport_ZeroAuth_Inspired_Audit_20240730_v6.md` (确认 `/config` 非优先，明确 webhook `flow_id` 猜测难度)
*   `DeepDiveReport_API_Review_Item_001.md` (包含对 CustomComponent `eval()` 的初步发现)
*   `DeepDiveReport_ValidateCodeRCE_Contradiction_20240729.md` (确认 `/validate/code` 在 `AUTO_LOGIN=false` 时需认证)

---

## 1. 核心目标1：高风险模式识别 (除 `/api/v1/validate/code` 外)

本次审计识别出 Langflow v1.4.2 中多个组件和内部函数采用了将用户可控输入（通常是字符串形式的代码或表达式）通过 AST 解析、动态代码构建与执行（如 `ast.parse`, `compile`, `exec`, `eval`）的高风险模式。这些模式与 CVE-2023-43789 揭示的核心风险一致。

### 1.1. 自定义组件 (CustomComponent) 系统

*   **涉及模块/函数:**
    *   `src/backend/base/langflow/custom/eval.py`: `eval_custom_component_code(code: str)` -> `validate.create_class(code, class_name)`
    *   `src/backend/base/langflow/utils/validate.py`: `create_class(code, class_name)` -> 使用 `ast.parse(code)`, `compile(...)`, `exec(...)` 来动态创建类。
    *   `src/backend/base/langflow/interface/custom/utils.py`: `evaluate_code(code: str, ...)` -> 直接使用 `eval(code, ...)`。(此项在 `DeepDiveReport_API_Review_Item_001.md` 中已有提及，此处重申其高风险模式)。
*   **高风险模式描述:** 用户通过API（通常需要认证）提供的代码字符串（作为自定义组件定义的一部分）被系统解析并执行，以动态生成和实例化组件类。
*   **输入来源:** 组件代码字符串，通常在创建或更新自定义组件时通过认证API（如 `POST /api/v1/custom_component/` 或在流程定义中）提供。
*   **认证要求:** 创建和修改自定义组件或包含它们的流程通常需要认证。

### 1.2. PythonFunctionComponent

*   **涉及模块/函数:**
    *   `src/backend/base/langflow/components/prototypes/python_function.py`: `PythonFunctionComponent` 类。
    *   其 `get_function_callable()` 方法获取 `self.function_code` (来自组件输入)。
    *   调用 `get_function(function_code)` (在 `src/backend/base/langflow/custom/utils.py` 中)。
    *   `get_function(code)` 调用 `validate.create_function(code, function_name)` (在 `src/backend/base/langflow/utils/validate.py` 中)。
    *   `validate.create_function` 使用 `ast.parse(code)`, `compile(...)`, `exec(...)` 来动态创建和执行函数。
*   **高风险模式描述:** `PythonFunctionComponent` 允许用户在其 `function_code` 输入字段中提供 Python 代码字符串。此代码在流程执行期间被解析、编译和执行。
*   **输入来源:** 组件的 `function_code` 参数值，该值在流程设计时定义，可以硬编码，也可以连接到其他组件的输出。
*   **认证要求:** 使用此组件构建流程或执行包含此组件的流程通常需要认证。

### 1.3. PythonREPLToolComponent

*   **涉及模块/函数:**
    *   `src/backend/base/langflow/components/tools/python_repl.py`: `PythonREPLToolComponent` 类。
    *   其 `build_tool()` 方法创建 `langchain_experimental.utilities.PythonREPL` 实例。
    *   `run_python_code(code: str)` 方法调用 `python_repl.run(code)`，后者执行任意 Python 代码。
*   **高风险模式描述:** `PythonREPLToolComponent` 允许用户在其 `code` 输入字段中提供 Python 代码字符串，该代码随后由 LangChain 的 Python REPL 工具执行。
*   **输入来源:** 组件的 `code` 参数值，在流程设计时定义。
*   **认证要求:** 使用此组件构建流程或执行包含此组件的流程通常需要认证。

---

## 2. 核心目标2：高风险模式在零权限下的间接可利用性分析

在 `AUTO_LOGIN = false` 且攻击者初始零权限的前提下，上述所有高风险模式的直接利用（例如，通过调用 `/api/v1/custom_component/` 创建恶意组件，或直接执行包含恶意 `PythonFunctionComponent` 的流程）均因需要认证而被阻止。

然而，存在通过 **Webhook 端点 (`/api/v1/webhook/{flow_id_or_name}`)** 进行间接利用的潜在攻击路径。此端点本身允许未经认证的调用，执行权限基于流程所有者。

### 2.1. 间接利用场景：Webhook 触发高风险组件

**攻击流程假设:**

1.  **前提1: `endpoint_name` 泄露/可猜测。** 攻击者必须知道一个已配置为 Webhook 的流程的 `endpoint_name` (或极难猜测的 `flow_id`)。`endpoint_name` 是用户自定义的字符串，如果设置为通用或可预测的名称（如 "chat", "submit_form", "process_data"），则可能被猜到。泄露也可能通过客户端代码、文档或其他途径发生。
2.  **前提2: 流程设计缺陷。** 目标流程 (`endpoint_name` 对应的流程) 必须包含以下结构：
    *   一个作为 Webhook 入口的组件（如 `WebhookComponent` 或配置为接受 Webhook 输入的 `TextInput` 等）。
    *   该入口组件的输出（包含攻击者通过 Webhook POST 请求发送的数据）被连接到以下任一高风险组件的 **代码输入字段**：
        *   `PythonFunctionComponent` 的 `function_code` 输入。
        *   `PythonREPLToolComponent` 的 `code` 输入。
        *   一个特殊设计的 `CustomComponent`，其代码本身是固定的，但它有一个类型为 `CodeInput` 或 `StrInput` 的字段用于接收要执行的代码，并且这个字段从 Webhook 入口组件获取其值。

**技术细节分析:**

*   **Webhook 数据传递:**
    *   `/api/v1/webhook/{flow_id_or_name}` (在 `src/backend/base/langflow/api/v1/endpoints.py`) 接收原始 POST 请求体 (`data = await request.body()`)。
    *   它查找流程中被标记为 Webhook 的组件 (`get_all_webhook_components_in_flow`)。
    *   对于每个此类组件，它构造 `tweaks` 字典：`tweaks[component["id"]] = {"data": decoded_attacker_payload}`。
    *   这些 `tweaks` 被传递给 `simple_run_flow_task` -> `simple_run_flow` -> `process_tweaks`。
    *   `process_tweaks` (在 `src/backend/base/langflow/processing/process.py`) 应用这些 `tweaks`。具体来说，`apply_tweaks` 函数会将 `node.data.node.template["data"]["value"]` (对于 WebhookComponent 的 "data" 字段) 设置为攻击者的载荷。
*   **`WebhookComponent` 的行为:**
    *   `src/backend/base/langflow/components/data/webhook.py` 中的 `WebhookComponent` 的 `build_data()` 方法处理 `self.data` (即攻击者的载荷)。
    *   如果载荷是有效 JSON，它将解析后的 JSON 作为 `Data(data=body)` 返回。
    *   如果不是有效 JSON，它会将原始载荷包装在 `{"payload": self.data}` 中，并作为 `Data(data=body)` 返回。
    *   此 `Data` 对象作为组件的 "output_data" 输出。
*   **数据流向高风险组件:**
    *   如果 `WebhookComponent` 的 "output_data" 连接到 `PythonFunctionComponent` 的 "function_code" (`CodeInput`) 或 `PythonREPLToolComponent` 的 "code" (`StrInput`):
        *   Langflow 的流程执行引擎会将 `Data` 对象（或其文本表示）传递给这些输入字段。
        *   如果 `PythonFunctionComponent.get_function()` 或 `PythonREPLToolComponent` 的执行逻辑直接将接收到的字符串（来自 `Data.text` 或 `str(Data.data)`) 作为代码执行，则 RCE 即可实现。

**总结此向量:**

*   **可行性:** **有条件可行。** 严重依赖于 `endpoint_name` 的可发现性以及存在设计不安全的流程（将 Webhook 输入直接或间接连接到代码执行组件的动态代码输入参数）。
*   **影响:** 如果成功，将允许未经认证的远程攻击者在服务器上以流程所有者的权限执行任意代码。

### 2.2. 其他间接向量的简要考虑

*   **SSRF 联动:** 如果系统中存在任何其他未经认证的 SSRF 漏洞点（即使是低风险、仅限内部网络的），理论上可以利用该 SSRF 从内部网络调用需要认证的高风险 API 端点（如 `/api/v1/custom_component/`，或直接调用 `/api/v1/validate/code`）。这需要先发现此类 SSRF，目前未进行此方向的深入调查。
*   **公共功能与内部逻辑的意外交互:** Langflow 的公开功能（在 `AUTO_LOGIN=false` 时）主要局限于读取公开流程/示例或触发 Webhook。直接从这些功能意外调用内部高风险组件并传递用户输入的可能性较低，除非是通过上述 Webhook 路径。
*   **对“用户输入”来源的扩展思考:**
    *   如果低权限认证用户能够篡改数据库中存储的流程定义或组件配置，并且这些被篡改的定义后续被高权限用户或系统自动执行，则可能导致权限提升。但这不属于零权限攻击者的直接路径。
*   **请求走私、参数污染:** 这些是通用的 Web 攻击技术，在复杂系统中可能存在机会，但没有发现特定于此目标的明显脆弱点。利用难度通常较高。

---

## 3. CVE 风格描述草案 (针对通过 Webhook 的间接 RCE)

*   **漏洞类型 (CWE):** CWE-94 (Improper Control of Generation of Code - 'Code Injection') via CWE-306 (Missing Authentication for Critical Function) for the webhook trigger if `endpoint_name` is guessable/leaked, and CWE-20 (Improper Input Validation) within the flow logic connecting webhook input to code execution component.
*   **受影响组件 (及版本):**
    *   Langflow v1.4.2 Webhook endpoint (`/api/v1/webhook/{flow_id_or_name}`).
    *   Langflow v1.4.2 `PythonFunctionComponent` (in `src/backend/base/langflow/components/prototypes/python_function.py`).
    *   Langflow v1.4.2 `PythonREPLToolComponent` (in `src/backend/base/langflow/components/tools/python_repl.py`).
    *   Potentially `CustomComponent` if designed to take code input dynamically from a flow connection.
*   **漏洞摘要:** Langflow v1.4.2 的 Webhook 端点允许未经认证的调用。如果一个流程的 `endpoint_name` 被泄露或猜到，并且该流程将来自 Webhook 的用户可控输入连接到 `PythonFunctionComponent` 的 `function_code` 参数、`PythonREPLToolComponent` 的 `code` 参数或类似的可动态提供代码的自定义组件参数，则未经认证的远程攻击者可以通过发送特制的 POST 请求到 Webhook 端点来触发这些组件执行任意 Python 代码。
*   **攻击向量/利用条件:**
    1.  远程，未经认证的攻击者。
    2.  Langflow 实例配置为 `AUTO_LOGIN = false`。
    3.  攻击者需知道一个已启用 Webhook 功能的流程的 `endpoint_name` (或 `flow_id`)。
    4.  目标流程必须存在设计缺陷：将 Webhook 输入组件的输出（包含攻击者数据）连接到代码执行组件（如 `PythonFunctionComponent`, `PythonREPLToolComponent`）的“代码”输入参数。
*   **技术影响:** 成功利用将允许攻击者在 Langflow 应用服务器上以流程所有者的权限执行任意 Python 代码，可能导致服务器完全被控制、数据泄露或进一步的网络渗透。

---

## 4. 安全审计师评估与PoC (间接 Webhook RCE)

*   **可达性:** 远程 (通过 Webhook 端点)。
*   **所需权限:** 无直接认证需要调用 Webhook。但需要知道 `endpoint_name`。
*   **潜在影响 (情境化):** **高至严重。** 如果前提条件满足，可导致 RCE。部署架构报告 (`DeploymentArchitectureReport.md`) 显示 Langflow 后端服务 (端口 7860) 直接公网暴露，加剧了此风险。

**概念验证 (PoC) - 理论步骤:**

*   **分类:** 远程。
*   **PoC 描述:** 攻击者通过已知的 Webhook `endpoint_name` 发送恶意 Python 代码，该代码由流程中配置不当的 `PythonFunctionComponent` 执行。
*   **前提条件:**
    1.  Langflow v1.4.2 实例运行，`AUTO_LOGIN = false`。
    2.  存在一个流程，其 `endpoint_name` 为 `vulnerable_flow`。
    3.  此流程包含以下连接：
        *   `WebhookComponent` (ID: `webhook_input_node`)
        *   `PythonFunctionComponent` (ID: `python_exec_node`)
        *   `webhook_input_node` 的 `output_data` 输出连接到 `python_exec_node` 的 `function_code` 输入。
*   **复现步骤:**
    1.  攻击者构造恶意 Python 代码，例如:
        `__import__('os').system('touch /tmp/pwned_by_webhook')`
    2.  攻击者向 Webhook 端点发送 POST 请求:
        ```bash
        curl -X POST -H "Content-Type: text/plain" --data "__import__('os').system('touch /tmp/pwned_by_webhook')" http://<langflow_host>:7860/api/v1/webhook/vulnerable_flow
        ```
        (注: `Content-Type` 可能需要调整，取决于 `WebhookComponent` 如何处理和传递数据。如果它直接传递字符串，`text/plain` 可能有效。如果它期望 JSON，则 payload 需要是 JSON 编码的字符串。)
*   **预期结果:**
    *   服务器上的 `/tmp/pwned_by_webhook` 文件被创建，表明代码已执行。
    *   Webhook 请求本身可能返回 `{"message": "Task started in the background", "status": "in progress"}`。
*   **PoC 依赖的关键假设:**
    *   `endpoint_name` ("vulnerable_flow") 已知。
    *   存在上述描述的流程连接：`WebhookComponent` 输出 -> `PythonFunctionComponent`的 `function_code` 输入。 Langflow 的数据传递机制会将 `WebhookComponent` 输出的 `Data` 对象（或其字符串表示）正确地填充到 `PythonFunctionComponent` 的 `function_code` 字段中，并被后者作为纯代码字符串执行。

---

## 5. 总结与建议

Langflow v1.4.2 中，除了已知的 `/api/v1/validate/code` (`AUTO_LOGIN=false` 时需认证)，还存在多个其他组件和内部功能采用将用户可控字符串作为代码执行的高风险模式，包括自定义组件系统、`PythonFunctionComponent` 和 `PythonREPLToolComponent`。

在 `AUTO_LOGIN=false` 和零初始权限的前提下，这些高风险模式的直接利用受到认证机制的保护。然而，通过 Webhook 端点的间接攻击路径是理论上可行的：如果一个 Webhook 的 `endpoint_name` 可被发现，并且其关联的流程将 Webhook 输入不安全地连接到上述任一高风险组件的代码输入参数，则可能导致未经认证的远程代码执行。

**建议修复方案:**

1.  **Webhook 安全强化:**
    *   **`endpoint_name` 随机性/保密性:** 考虑在生成 Webhook URL 时，除了用户可定义的 `endpoint_name` 外，强制加入一个长的、不可预测的随机令牌部分，以防止猜测。
    *   **输入净化/限制:** 对于从 Webhook 传入并流向高风险组件（如 `PythonFunctionComponent` 的 `function_code` 字段）的数据，应默认进行严格的净化，或完全禁止此类连接。理想情况下，动态代码输入字段不应从外部不可信源（如 Webhook）直接填充。
    *   **明确风险提示:** 在 UI 中，当用户将 Webhook 输入连接到能执行代码的组件参数时，应提供强烈的安全警告。
2.  **高风险组件的输入处理:**
    *   对于 `PythonFunctionComponent`, `PythonREPLToolComponent` 等，当其代码输入字段从其他组件动态获取值时，应考虑对输入值进行更严格的类型检查和内容限制。例如，不允许包含典型的 OS 命令注入字符或模式。
    *   考虑为这些“代码输入”字段增加一个“来源可信度”标记，如果来源不可信（如 Webhook），则拒绝执行或在沙箱中执行。
3.  **沙箱化执行 (通用建议):** 任何执行用户提供代码的功能（包括自定义组件、Python 函数组件等）都应考虑在严格的沙箱环境中执行，以限制其潜在危害。
4.  **代码审查与安全意识:** 持续进行安全代码审查，特别是涉及动态代码执行、输入处理和认证授权的模块。提高开发者关于安全编码实践的意识。

---